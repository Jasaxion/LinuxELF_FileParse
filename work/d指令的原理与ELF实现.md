# 选项-d 的原理和具体实现

## 1.选项-d 的介绍

### 1.1.重定位

重定位操作是连接符号引用（symbolic references）和符号定义（symbolic definitions）的过程。例如，程序中调用一个（外部）函数，代码中我们只需要指定函数名（符号引用）即可，但是当程序实际运行的时候，相关的CALL指令必须能够正确无误地跳转到函数实际地址处（符号定义）去执行函数代码。可是在链接阶段之前，符号的虚拟地址（亦可称运行时地址）并没有分配，只有在链接阶段的符号解析过程中链接器才会为符号分配虚拟地址。在符号地址确认后，链接器这才会修改机器指令（即重定位操作是在符号解析之后），可是链接器并不会聪明到可以自动找到可重定位文件中引用外部符号的地方（即需要修改的地方），所以可重定位文件必须提供相应的信息来帮助链接器，换句话说，可重定位文件中必须包含相关的信息来告诉链接器如何去修改节的内容，只有这样，最后生成的可执行文件或者共享库才会包含正确的信息来构建最终的进程映像。可重定位项就是帮助链接器进行重定位操作的信息。

重定位就是把符号引用与符号定义链接起来的过程。

当程序中调用一个函数时，相关的 call 指令必须在执行期将控制流转到正确的目标地址。所以，so 文件中必须包含一些重定位相关的信息，linker 据此完成重定位的工作。

例如两种基本的重定位类型R_386_32和R386_PC32：

| 宏定义     | 值 | 重定位修正方法    |
| ---------- | -- | ----------------- |
| R_386_32   | 1  | 绝对寻址修正S+A   |
| R_386_PC32 | 2  | 相对寻址修正S+A-P |

* A=保存正在修正位置的值；
* P=被修正的位置（相对于节区开始的偏移量或虚拟地址）；
* S=符号的实际地址，即由r_info的高24位指定的符号的实际地址。

### 1.2.重定位表数据结构

在.o文件链接时将发生重定位
这些重定位信息保存在一系列的重定位项中（.rel.dyn等表），重定位项的结构如下：

```c
typedef struct
{
    Elf32_Addr  r_offset;       /* Address */
    Elf32_Word  r_info;         /* Relocation type and symbol index */
} Elf32_Rel;

typedef struct
{
    Elf32_Addr  r_offset;       /* Address */
    Elf32_Word  r_info;         /* Relocation type and symbol index */
    Elf32_Sword r_addend;       /* Addend */
} Elf32_Rela;
```

#### 1.2.1.r_offset

本数据成员给出重定位所作用的位置。对于重定位文件来说,此值是受重定位作用的存储单元在节中的字节偏移量;

对于可执行文件或共享ELF文件来说,此值是受重定位作用的存储单元的虚拟地址。

#### 1.2.2.r_info

本数据成员既给出了重定位所作用的符号表索引,也给出了重定位的类型。以下是应用于 r_info 的宏定义。

```c
#define ELF32_R_SYM(val)        ((val) >> 8)  //得到符号表的索引
#define ELF32_R_TYPE(val)       ((val) & 0xff)  //得到type
#define ELF32_R_INFO(sym, type)     (((sym) << 8) + ((type) & 0xff))
```

#### 1.2.3.r_addend

本成员指定了一个加数,这个加数用于计算需要重定位的域的值。

Elf32_Rela 与 Elf32_Rel 在结构上只有一处不同,就是前者有 r_addend。Elf32_Rela 中是用r_addend 显式地指出加数;而对 Elf32_Rel来说,加数是隐含在被修改的位置里的。Elf32_Rel中加数的形式这里并不定义,它可以依处理器架构(ELF32_R_TYPE(info))的不同而自行决定。

#### 1.2.4.计算方式

计算方式是根据ELF32_R_TYPE宏定义得到类型决定的，例如i386架构的计算方式：

被重定位域(relocatable field)是一个 32 位的域，占 4 字节并且地址向4字节对齐，其字节序与所在体系结构下其他双字长数据的字节序相同。重定位项用于描述如何修改如下的指令和数据域:

![img](https://upload-images.jianshu.io/upload_images/23598658-f42d288cfb97ceeb.png?imageMogr2/auto-orient/strip|imageView2/2/w/438/format/webp)

为了下面的描述方便,这里定义以下几种运算符号:

* A 表示用于计算重定位域值的加数。
* B 表示在程序运行期,共享ELF被装入内存时的基地址。一般来说,共享ELF文件在构建时基地址为 0,但在运行时则不是。
* G 表示可重定位项在全局偏移量表中的位置,这里存储了此重定位项在运行期间的地址。更多信息参见下文“全局偏移量表”。
* GOT 表示全局偏移量表的地址。
* L 表示一个符号的函数连接表项的所在之处,可能是节内偏移量,或者是内存地址。函数连接表项把函数调用定位到合适的位置。在构建期间,连接编辑器创建初始的函数连接表;在运行期间,动态连接器会修改表项。更多信息参见“函数连接表”部分。
* P 表示被重定位的存储单元在节内的偏移量或者内存地址,由 r_offset 计算得到。
* S 表示重定位项中某个索引值所代表的符号的值。

重定位类型指定了哪些位需要被修改以及如何算计它们的值，下面使用x86系统处理器的重定位类型的计算方法说明。

| 名字           | 值 | 数据类型 | 计算    |
| -------------- | -- | -------- | ------- |
| R_386_GOT32    | 3  | word32   | G+A     |
| R_386_PLT32    | 4  | word32   | L+A-P   |
| R_386_COPY     | 5  | none     | none    |
| R_386_GLOB_DAT | 6  | word32   | S       |
| R_386_JMP_SLOT | 7  | word32   | S       |
| R_386_RELATIVE | 8  | word32   | B+A     |
| R_386_GOTOFF   | 9  | word32   | S+A-GOT |
| R_386_GOTPC    | 10 | word32   | GOT+A-P |

## 2.选项-d 的作用

## 3.选项-d 显示的信息解释

## 4.代码实现

### 4.1.算法思路

### 4.2.流程图

### 4.3.测试

### 4.4.代码详细解释
